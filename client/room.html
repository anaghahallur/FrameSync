<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room ‚Ä¢ FrameSync</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* Room-Specific Overrides */
    body {
      padding: 20px;
      overflow: hidden;
      /* Prevent full page scroll, handle in containers */
    }

    .room-container {
      max-width: 1600px;
      margin: 0 auto;
      display: flex;
      gap: 20px;
      height: calc(100vh - 40px);
    }

    .video-section {
      flex: 3;
      background: var(--bg-card);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 20px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      position: relative;
    }

    .side-section {
      flex: 1;
      background: var(--bg-card);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 20px;
      display: flex;
      flex-direction: column;
      min-width: 300px;
    }

    #video-player {
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid var(--border);
    }

    .host-controls {
      display: none;
      gap: 15px;
      margin-bottom: 20px;
      background: var(--bg-panel);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .user-list,
    .chat-box {
      background: var(--bg-panel);
      border-radius: 12px;
      padding: 15px;
      margin-top: 15px;
      flex-grow: 1;
      overflow-y: auto;
      border: 1px solid var(--border);
    }

    .chat-box {
      max-height: 400px;
    }

    .leave-btn {
      margin-top: auto;
      background: #b91c1c !important;
      /* Darker red for leave */
      border-color: #b91c1c !important;
      color: white;
    }

    .leave-btn:hover {
      background: #dc2626 !important;
    }

    /* Button Overrides removed to match dashboard style.css */
    /* .btn class will now inherit from button tag in style.css */

    .chat-send-btn {
      width: 100%;
      margin-top: 15px;
    }

    .user-list {
      min-height: 150px;
      color: var(--text-main);
    }

    /* Ensure text is visible in inputs */
    input[type="text"] {
      color: white;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
    }

    .chat-send-btn {
      width: 100%;
      margin-top: 15px;
    }

    /* Tabs Overrides */
    .tab-btn {
      color: var(--text-muted);
      transition: 0.3s;
      font-size: 1rem;
      padding: 10px 20px;
    }

    .tab-btn:hover {
      color: white;
    }

    .tab-btn.active {
      color: var(--accent) !important;
      border-bottom-color: var(--accent) !important;
    }

    /* Video Bubble Overrides for Theme */
    .video-bubble {
      border-color: var(--accent);
      background: var(--bg-card);
    }

    .avatar-placeholder {
      background: var(--bg-panel);
      color: var(--text-muted);
    }
  </style>
</head>

<body>


  <!-- CUSTOM STYLES FOR FLOATING UI -->
  <style>
    .bottom-toolbar {
      width: 100%;
      height: 60px;
      background: var(--bg-panel);
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 30px;
      z-index: 100;
      position: absolute;
      bottom: 0;
      left: 0;
    }

    .icon-btn {
      background: none;
      border: none;
      font-size: 1.6rem;
      cursor: pointer;
      opacity: 0.6;
      transition: 0.2s;
      padding: 10px;
      border-radius: 12px;
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon-btn:hover,
    .icon-btn.active {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
      color: var(--accent);
      transform: scale(1.1);
    }

    .floating-panel {
      position: absolute;
      top: 0;
      right: 0;
      width: 320px;
      height: calc(100% - 60px);
      /* Subtract toolbar height */
      background: rgba(10, 10, 10, 0.95);
      backdrop-filter: blur(15px);
      border-left: 1px solid var(--border);
      transform: translateX(120%);
      transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
      z-index: 90;
      display: flex;
      flex-direction: column;
      padding: 20px;
      box-shadow: -10px 0 30px rgba(0, 0, 0, 0.5);
    }

    .floating-panel.open {
      transform: translateX(0);
    }

    .panel-header {
      font-size: 1.4rem;
      font-weight: 800;
      margin-bottom: 20px;
      color: var(--accent);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px;
    }
  </style>

  <!-- MAIN CONTAINER (Refactored) -->
  <div class="room-container"
    style="display:flex; flex-direction:column; width:100%; height:calc(100vh - 80px); position:relative; overflow:hidden;">

    <!-- VIDEO SECTION (Full Width) -->
    <div class="video-section"
      style="flex:1; padding:20px; display:flex; flex-direction:column; overflow:hidden; position:relative; padding-bottom:80px;">
      <div id="player-container"
        style="width:100%; height:100%; background:#000; border-radius:24px; margin-bottom:0; overflow:hidden; position:relative; flex:1;">
        <div id="video-player" style="height:100%; width:100%;"></div>
        <!-- Remove 'controls' attribute by default -->
        <video id="html5-player" style="width:100%; height:100%; display:none;"></video>

        <!-- GUEST OVERLAY (Blocks interaction) -->
        <div id="guest-overlay"
          style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; z-index:10; cursor:default;">
        </div>
      </div>

      <!-- HOST CONTROLS (Floating Overlay) -->
      <div id="host-controls" class="host-controls"
        style="display:none; position:absolute; bottom:90px; left:50%; transform:translateX(-50%); width:600px; background:rgba(0,0,0,0.8); backdrop-filter:blur(10px); padding:15px; border-radius:16px; border:1px solid rgba(255,255,255,0.1); z-index:80; flex-direction:column; gap:10px;">

        <div style="display:flex; justify-content:space-between; align-items:center; width:100%;">
          <div style="display:flex; gap:10px;">
            <button onclick="switchControlTab('youtube')" class="btn"
              style="padding:8px 15px; font-size:0.9rem;">YouTube</button>
            <button onclick="switchControlTab('file')" class="btn"
              style="padding:8px 15px; font-size:0.9rem;">File</button>
          </div>

          <!-- YouTube Inputs -->
          <div id="tab-youtube" class="control-tab" style="flex:1; display:flex; gap:10px; margin-left:15px;">
            <input type="text" id="youtube-link" placeholder="Paste YouTube link..."
              style="flex:1; padding:8px; background:rgba(255,255,255,0.1); border:1px solid #444; color:white; border-radius:6px;">
            <button class="btn" onclick="loadYouTube()" style="padding:8px 15px;">Load</button>
          </div>

          <!-- File Inputs -->
          <div id="tab-file" class="control-tab"
            style="display:none; flex:1; gap:10px; align-items:center; margin-left:15px;">
            <label class="btn" style="cursor:pointer; padding:8px;">üìÇ <input type="file" id="file-upload"
                accept="video/*" style="display:none" onchange="handleFileSelect(this, 'video')"></label>
            <label class="btn" style="cursor:pointer; padding:8px;">üìÑ <input type="file" id="sub-upload"
                accept=".vtt,.srt" style="display:none" onchange="handleFileSelect(this, 'subtitle')"></label>
            <button class="btn" onclick="uploadFiles()" style="padding:8px;">Play</button>
          </div>
        </div>
      </div>
    </div>

    <!-- BOTTOM TOOLBAR (Icons) -->
    <div class="bottom-toolbar">
      <button id="btn-users" class="icon-btn" onclick="togglePanel('user-panel')" title="Users">üë•</button>
      <button id="btn-chat" class="icon-btn" onclick="togglePanel('chat-panel')" title="Chat">üí¨</button>
      <div style="width:1px; height:30px; background:var(--border); margin:0 10px;"></div>
      <button class="icon-btn leave-btn" onclick="leaveRoom()" title="Leave Room"
        style="color:#ff4444 !important;">üö™</button>
      <!-- Host Control Toggle (Visible if Host) -->
      <button id="btn-host-tools" class="icon-btn" onclick="toggleHostControls()" style="display:none;"
        title="Host Tools">üõ†Ô∏è</button>
    </div>

    <!-- FLOATING USER PANEL -->
    <div id="user-panel" class="floating-panel">
      <div class="panel-header">Users <span id="peer-count"
          style="font-size:0.9rem; font-weight:normal; opacity:0.7;">(0)</span></div>
      <div id="user-list" class="user-list" style="flex:1; overflow-y:auto; padding-right:5px;"></div>
    </div>

    <!-- FLOATING CHAT PANEL -->
    <div id="chat-panel" class="floating-panel">
      <div class="panel-header">Chat</div>
      <div id="chat-box" class="chat-box"
        style="flex:1; overflow-y:auto; margin-bottom:15px; background:rgba(0,0,0,0.2); border-radius:8px; padding:10px;">
      </div>

      <div style="display:flex; gap:10px; margin-bottom:15px;">
        <input type="text" id="chat-input" placeholder="Message..." onkeypress="if(event.key==='Enter') sendMessage()"
          style="flex:1;">
        <button class="btn chat-send-btn" onclick="sendMessage()" style="margin:0; padding:0 15px;">‚û§</button>
      </div>

      <!-- REACTION BAR -->
      <div id="reaction-bar" style="display:grid; grid-template-columns:repeat(3, 1fr); gap:8px;">
        <button onclick="sendReaction('‚ù§Ô∏è')" class="btn"
          style="background:rgba(255,255,255,0.1); border:none; padding:8px;">‚ù§Ô∏è</button>
        <button onclick="sendReaction('üòÇ')" class="btn"
          style="background:rgba(255,255,255,0.1); border:none; padding:8px;">üòÇ</button>
        <button onclick="sendReaction('üòÆ')" class="btn"
          style="background:rgba(255,255,255,0.1); border:none; padding:8px;">üòÆ</button>
        <button onclick="sendReaction('üò¢')" class="btn"
          style="background:rgba(255,255,255,0.1); border:none; padding:8px;">üò¢</button>
        <button onclick="sendReaction('üò°')" class="btn"
          style="background:rgba(255,255,255,0.1); border:none; padding:8px;">üò°</button>
        <button onclick="sendReaction('üéâ')" class="btn"
          style="background:rgba(255,255,255,0.1); border:none; padding:8px;">üéâ</button>
      </div>
    </div>

  </div>

  <script>
    // Toggle Logic for Panels
    function togglePanel(id) {
      const panel = document.getElementById(id);
      const isOpen = panel.classList.contains('open');

      // Close all first (Exclusive mode)
      document.querySelectorAll('.floating-panel').forEach(p => p.classList.remove('open'));
      document.querySelectorAll('.icon-btn').forEach(b => b.classList.remove('active'));

      if (!isOpen) {
        panel.classList.add('open');
        if (id === 'user-panel') document.getElementById('btn-users').classList.add('active');
        if (id === 'chat-panel') document.getElementById('btn-chat').classList.add('active');
      }
    }

    function toggleHostControls() {
      const controls = document.getElementById('host-controls');
      const btn = document.getElementById('btn-host-tools');
      if (controls.style.display === 'none') {
        controls.style.display = 'flex';
        btn.classList.add('active');
      } else {
        controls.style.display = 'none';
        btn.classList.remove('active');
      }
    }
  </script>



  <!-- SOCKET.IO + YOUTUBE API -->
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>

  <script>
    const socket = io();
    const roomCode = new URLSearchParams(window.location.search).get('code');
    const userName = localStorage.getItem('userName') || 'Guest';

    // Use Session Storage to prevent tab conflicts
    const isHost = sessionStorage.getItem('isHost') === 'true';

    let ytPlayer;
    let currentMode = 'youtube'; // 'youtube' or 'file'
    let isSyncing = false; // Prevent feedback loops

    let selectedVideo = null;
    let selectedSubtitle = null;

    // Debounce function to prevent event spam
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // Auth Check
    if (localStorage.getItem('isLoggedIn') !== 'true') {
      alert("You must be logged in to join a room.");
      location.href = 'index.html';
    }

    // Join Room
    const token = localStorage.getItem('token');
    const email = localStorage.getItem('userEmail');
    // We need to fetch our own userId to know who we are for friend requests
    // For now, we'll rely on the server broadcasting events with IDs.
    // Ideally, we should fetch /api/me to get our ID, but we'll use the token/email in joinRoom.

    socket.emit('joinRoom', { roomCode, userName, isHost, token, email });

    // User List with Friend Options
    let myUserId = null;

    socket.on('updateUsers', (users) => {
      // Update Bubbles for all users
      console.log("updateUsers received:", users);

      // robustly find myUserId using socket.id
      const me = users.find(u => u.socketId === socket.id);
      if (me) myUserId = me.userId;

      // Update badge count
      document.getElementById('peer-count').textContent = `(${users.length})`;

      users.forEach(u => {
        // ... (bubble logic remains same, just ensuring context)
        console.log(`Processing user: ${u.name}, socketId: ${u.socketId}, mySocketId: ${socket.id}`);
        if (!u.socketId) {
          console.error("Missing socketId for user:", u);
          if (!sessionStorage.getItem('server_restart_alert')) {
            alert("Please restart the server (Ctrl+C -> node server.js) to enable video bubbles.");
            sessionStorage.setItem('server_restart_alert', 'true');
          }
          return;
        }
        let bubble = document.getElementById(`bubble-${u.socketId}`);
        if (!bubble) {
          bubble = document.createElement('div');
          bubble.id = `bubble-${u.socketId}`;
          bubble.className = 'video-bubble';
          // Random initial position (within bounds)
          const maxX = window.innerWidth - 160;
          const maxY = window.innerHeight - 160;
          bubble.style.top = Math.min(Math.max(100, 100 + Math.random() * 200), maxY) + 'px';
          bubble.style.left = Math.min(Math.max(20, Math.random() * maxX), maxX) + 'px';

          const isMe = (u.socketId === socket.id);
          const initial = u.name.charAt(0).toUpperCase();
          const avatarUrl = u.avatar || null;

          bubble.innerHTML = `
             <div class="avatar-placeholder" style="border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; overflow:hidden;">
                ${avatarUrl
              ? `<img src="${avatarUrl}" style="width:100%; height:100%; object-fit:cover;">`
              : initial}
             </div>
             <video id="video-${u.socketId}" autoplay playsinline ${isMe ? 'muted style="transform:scaleX(-1);"' : ''} style="display:none;"></video>
             <div class="name-tag">${isMe ? 'You' : u.name}</div>
             ${isMe ? `
               <div id="connect-overlay" class="connect-overlay" onclick="startLocalVideo()">
                 <span style="font-size:2rem;">üìπ</span>
                 <span style="font-size:0.8rem; margin-top:5px;">Tap to Join</span>
               </div>
               <div id="local-controls" class="bubble-controls" style="display:none;">
                 <button onclick="toggleMute()" id="mute-btn" class="bubble-btn">üé§</button>
                 <button onclick="toggleVideo()" id="video-btn" class="bubble-btn">üì∑</button>
                 <button onclick="leaveCall()" class="bubble-btn" style="background:#ff3366;">‚ùå</button>
               </div>
             ` : ''}
           `;
          document.body.appendChild(bubble);
          makeDraggable(bubble);
        }
      });

      // Remove bubbles for users who left
      document.querySelectorAll('.video-bubble').forEach(el => {
        const socketId = el.id.replace('bubble-', '');
        if (!users.find(u => u.socketId === socketId)) {
          el.remove();
        }
      });

      document.getElementById('user-list').innerHTML = users.map(u => {
        const hostBadge = u.isHost ? ' <span style="color:#ffd700; font-size:0.9em;">üëë</span>' : '';
        let friendBtn = '';

        // Only show Add Friend button if:
        // 1. It's not me
        // 2. We have both user IDs
        // 3. We are NOT in a private room (assuming private rooms auto-friend, we hide button to avoid confusion)
        // For now, since we don't strictly know if room is private client-side without extra data, 
        // we will rely on the server's auto-friend logic. 
        // But to fix the UI complaint, we ensure we NEVER show it for ourselves.

        if (u.userId && myUserId && u.userId !== myUserId) {
          // Optional: You could fetch friend status here to hide if already friends
          friendBtn = `<button onclick="addFriend(${u.userId})" style="margin-left:10px; padding:2px 8px; font-size:0.8rem; background:var(--accent, #00eeff); border:none; border-radius:4px; color:black; cursor:pointer; font-weight:bold;">+</button>`;
        }

        const avatarUrl = u.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(u.name)}`;

        return `<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; padding:5px; border-radius:8px; background:rgba(255,255,255,0.05);">
                  <div style="display:flex; align-items:center; gap:10px;">
                      <img src="${avatarUrl}" style="width:32px; height:32px; border-radius:50%; object-fit:cover; border:1px solid var(--accent);">
                      <span>${u.name}${hostBadge}</span>
                  </div>
                  ${friendBtn}
                </div>`;
      }).join('');
    });

    window.addFriend = function (targetId) {
      if (!myUserId) return showToast("Error: User ID not found", "error");
      socket.emit('addFriend', { fromUserId: myUserId, toUserId: targetId });
      showToast("Friend request sent!", "success");
    };

    // Friend Events
    socket.on('friendRequestReceived', (data) => {
      // Check if it's for me (client-side filter if broadcasted to room)
      // Ideally server sends to specific socket, but we broadcasted to room in server.js
      // We need to know our own ID.
      if (myUserId && data.toUserId === myUserId) {
        const toast = document.createElement('div');
        toast.innerHTML = `
          <p><strong>${data.fromName}</strong> sent a friend request!</p>
          <button onclick="acceptFriend(${data.fromUserId}, this.parentElement)" style="margin-top:5px; background:white; color:black; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Accept</button>
        `;
        toast.style.cssText = `
          position:fixed; bottom:80px; right:30px; z-index:9999;
          background:#00eeff; color:black; padding:16px; border-radius:16px;
          font-weight:700; box-shadow:0 0 40px rgba(0,0,0,0.5);
          animation:slideIn 0.4s;
        `;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 10000);
      }
    });

    window.acceptFriend = function (fromId, toastElem) {
      socket.emit('acceptFriend', { userId: myUserId, friendId: fromId });
      toastElem.remove();
      showToast("Friend request accepted!", "success");
    };

    socket.on('friendRequestAccepted', (data) => {
      if (data.userId === myUserId || data.friendId === myUserId) {
        showToast("You are now friends!", "success");
      }
    });

    // Show host controls AND enable video controls for host
    if (isHost) {
      document.getElementById('btn-host-tools').style.display = 'flex';
      document.getElementById('html5-player').controls = true;
    } else {
      // Enable Overlay for Guests
      document.getElementById('guest-overlay').style.display = 'block';

      // Allow unmuting on click (browser policy)
      document.getElementById('guest-overlay').addEventListener('click', () => {
        if (ytPlayer && ytPlayer.unMute) ytPlayer.unMute();
        const html5 = document.getElementById('html5-player');
        if (html5) html5.muted = false;
      });
    }

    // YouTube Player Setup
    function onYouTubeIframeAPIReady() {
      ytPlayer = new YT.Player('video-player', {
        height: '100%',
        width: '100%',
        playerVars: {
          autoplay: 1,
          controls: isHost ? 1 : 0, // Hide controls for guest
          disablekb: isHost ? 0 : 1, // Disable keyboard for guest
          rel: 0
        },
        events: {
          'onReady': () => console.log("YouTube Ready"),
          'onStateChange': onPlayerStateChange
        }
      });
    }

    function onPlayerStateChange(event) {
      if (isHost && currentMode === 'youtube' && !isSyncing) {
        emitVideoState({
          roomCode,
          mode: 'youtube',
          state: event.data,
          time: ytPlayer.getCurrentTime()
        });
      }
    }

    // HTML5 Player Setup
    const html5Player = document.getElementById('html5-player');
    html5Player.crossOrigin = "anonymous";

    // Debounced Emit
    const emitVideoState = debounce((data) => {
      socket.emit('videoState', data);
    }, 100);

    html5Player.addEventListener('play', () => {
      if (isHost && currentMode === 'file' && !isSyncing) {
        emitVideoState({ roomCode, mode: 'file', state: 'play', time: html5Player.currentTime });
      }
    });

    html5Player.addEventListener('pause', () => {
      if (isHost && currentMode === 'file' && !isSyncing) {
        emitVideoState({ roomCode, mode: 'file', state: 'pause', time: html5Player.currentTime });
      }
    });

    html5Player.addEventListener('seeked', () => {
      if (isHost && currentMode === 'file' && !isSyncing) {
        emitVideoState({ roomCode, mode: 'file', state: 'seek', time: html5Player.currentTime });
      }
    });

    // Load YouTube (Host Only)
    function loadYouTube() {
      if (!isHost) return showToast("Only host can control video", "error");
      const url = document.getElementById('youtube-link').value.trim();
      const videoId = url.match(/(?:v=|\/)([a-zA-Z0-9_-]{11})/)?.[1];
      if (!videoId) return showToast("Invalid YouTube link", "error");

      // Switch to YouTube mode locally
      switchMode('youtube');
      ytPlayer.loadVideoById(videoId);

      socket.emit('loadVideo', { roomCode, videoId });
    }

    // Tab Switching
    function switchControlTab(tab) {
      document.querySelectorAll('.control-tab').forEach(el => el.style.display = 'none');
      document.querySelectorAll('.tab-btn').forEach(el => {
        el.style.opacity = '0.5';
        el.style.borderBottom = 'none';
      });

      document.getElementById(`tab-${tab}`).style.display = 'block';
      const btn = document.getElementById(`tab-${tab}-btn`);
      btn.style.opacity = '1';
      btn.style.borderBottom = '2px solid var(--accent)';
    }

    // File Selection
    function handleFileSelect(input, type) {
      const file = input.files[0];
      if (!file) return;

      if (type === 'video') {
        selectedVideo = file;
        document.getElementById('file-name-display').textContent = file.name;
        document.getElementById('file-name-display').style.color = '#00eeff';
      } else {
        selectedSubtitle = file;
        document.getElementById('sub-name-display').textContent = file.name;
        document.getElementById('sub-name-display').style.color = '#00eeff';
      }
    }

    // Upload Files (Host Only)
    async function uploadFiles() {
      if (!isHost) return;
      if (!selectedVideo) return showToast("Please select a video file", "error");

      const formData = new FormData();
      formData.append('video', selectedVideo);
      if (selectedSubtitle) {
        formData.append('subtitle', selectedSubtitle);
      }

      showToast("Uploading...", "info");

      try {
        const res = await fetch('/api/upload', { method: 'POST', body: formData });
        const data = await res.json();

        if (data.url) {
          // Switch to File mode locally
          switchMode('file');
          playFile(data.url, data.subtitleUrl);

          socket.emit('loadFile', {
            roomCode,
            url: data.url,
            subtitleUrl: data.subtitleUrl,
            filename: data.filename
          });
          showToast("Upload complete!", "success");
        }
      } catch (err) {
        console.error(err);
        showToast("Upload failed", "error");
      }
    }

    function playFile(url, subtitleUrl) {
      html5Player.src = url;
      html5Player.innerHTML = ''; // Clear old tracks

      if (subtitleUrl) {
        const track = document.createElement('track');
        track.kind = 'subtitles';
        track.label = 'English';
        track.srclang = 'en';
        track.src = subtitleUrl;
        track.default = true;
        html5Player.appendChild(track);

        // Force display using textTracks API
        html5Player.addEventListener('loadedmetadata', () => {
          if (html5Player.textTracks[0]) {
            html5Player.textTracks[0].mode = 'showing';
          }
        }, { once: true });
      }

      html5Player.play();
    }

    function switchMode(mode) {
      currentMode = mode;
      if (mode === 'youtube') {
        document.getElementById('video-player').style.display = 'block';
        document.getElementById('html5-player').style.display = 'none';
        html5Player.pause();
      } else {
        document.getElementById('video-player').style.display = 'none';
        document.getElementById('html5-player').style.display = 'block';
        if (ytPlayer && ytPlayer.pauseVideo) ytPlayer.pauseVideo();
      }
    }

    // Socket Events
    socket.on('loadVideo', (data) => {
      switchMode('youtube');
      if (ytPlayer && ytPlayer.loadVideoById) {
        ytPlayer.loadVideoById(data.videoId);
      }
    });

    socket.on('loadFile', (data) => {
      switchMode('file');
      playFile(data.url, data.subtitleUrl);
      showToast("Host loaded a file: " + data.filename);
    });

    // Sync video state
    socket.on('videoState', (data) => {
      if (isHost) return; // Host ignores incoming sync signals to avoid loops

      isSyncing = true; // Block outgoing events while syncing

      if (data.mode === 'youtube' && currentMode === 'youtube') {
        if (Math.abs(ytPlayer.getCurrentTime() - data.time) > 2) {
          ytPlayer.seekTo(data.time, true);
        }
        if (data.state === 1) ytPlayer.playVideo();
        if (data.state === 2) ytPlayer.pauseVideo();
      }
      else if (data.mode === 'file' && currentMode === 'file') {
        // Only sync if difference is significant to prevent micro-stutters
        if (Math.abs(html5Player.currentTime - data.time) > 0.5) {
          html5Player.currentTime = data.time;
        }
        if (data.state === 'play') html5Player.play().catch(e => console.log("Autoplay blocked"));
        if (data.state === 'pause') html5Player.pause();
      }

      setTimeout(() => isSyncing = false, 500); // Reset sync flag
    });

    // User List (Handled above with Friend Logic)

    // Chat
    socket.on('chatMessage', (msg) => {
      const chat = document.getElementById('chat-box');
      chat.innerHTML += `<p><strong>${msg.name}:</strong> ${msg.text}</p>`;
      chat.scrollTop = chat.scrollHeight;
    });

    // Room Ended
    socket.on('roomEnded', () => {
      alert("The host has left the room. The session has ended.");
      sessionStorage.removeItem('isHost');
      location.href = 'dashboard.html';
    });

    // Auth Error
    socket.on('authError', (data) => {
      alert(data.message);
      localStorage.clear();
      location.href = 'index.html';
    });

    function sendMessage() {
      const input = document.getElementById('chat-input');
      const text = input.value.trim();
      if (text) {
        socket.emit('chatMessage', { roomCode, text });
        input.value = '';
      }
    }

    function leaveRoom() {
      socket.emit('leaveRoom', roomCode);
      sessionStorage.removeItem('isHost');
      location.href = 'dashboard.html';
    }

    // Toast Function
    function showToast(message, type = "info") {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
      position:fixed; bottom:30px; right:30px; z-index:9999;
      background:${type === 'error' ? '#ff3366' : type === 'success' ? '#00ff88' : '#00eeff'};
      color:black; padding:16px 32px; border-radius:16px;
      font-weight:700; box-shadow:0 0 40px rgba(0,0,0,0.5);
      animation:slideIn 0.4s, slideOut 0.4s 2.6s forwards;
    `;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    // CSS Animations
    const style = document.createElement('style');
    style.textContent = `
    @keyframes slideIn { from { transform:translateX(100%); opacity:0; } to { transform:translateX(0); opacity:1; } }
    @keyframes slideOut { to { transform:translateX(100%); opacity:0; } }
    @keyframes floatUp { 
      0% { transform: translateY(0) scale(1); opacity: 1; } 
      100% { transform: translateY(-200px) scale(1.5); opacity: 0; } 
    }
    .floating-emoji {
      position: fixed;
      bottom: 100px;
      font-size: 2rem;
      pointer-events: none;
      animation: floatUp 2s ease-out forwards;
      z-index: 1000;
    }
    .video-bubble {
      position: fixed;
      width: 150px;
      height: 150px;
      border-radius: 50%;
      border: 3px solid var(--accent);
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      cursor: grab;
      z-index: 1500;
      background: #000;
      transition: transform 0.1s;
    }
    .video-bubble:active {
      cursor: grabbing;
      transform: scale(1.05);
    }
    .video-bubble video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .video-bubble .name-tag {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: bold;
      pointer-events: none;
      z-index: 2;
    }
    .bubble-controls {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 3;
    }
    .video-bubble:hover .bubble-controls {
      opacity: 1;
    }
    .bubble-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      border-radius: 50%;
      width: 35px;
      height: 35px;
      cursor: pointer;
      color: white;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    .bubble-btn:hover {
      background: var(--accent);
    }
    .connect-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 4;
    }
    .avatar-placeholder {
      width: 100%;
      height: 100%;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      font-weight: bold;
      color: #777;
      position: absolute;
      top: 0;
      left: 0;
    }
  `;
    document.head.appendChild(style);
    // --- WEBRTC VIDEO CHAT LOGIC ---
    let localStream;
    let peers = {}; // socketId -> RTCPeerConnection
    let isCallActive = false;

    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    function updatePeerCount() {
      const count = Object.keys(peers).length;
      console.log("Updating Peer Count:", count, peers);
      document.getElementById('peer-count').textContent = `(Peers: ${count})`;
    }

    // --- DRAG & DROP LOGIC (Generic) ---
    function makeDraggable(el) {
      let active = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;
      let xOffset = 0;
      let yOffset = 0;

      el.addEventListener("mousedown", dragStart, false);
      document.addEventListener("mouseup", dragEnd, false);
      document.addEventListener("mousemove", drag, false);

      function dragStart(e) {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
        if (e.target === el || e.target.parentNode === el) {
          active = true;
        }
      }

      function dragEnd(e) {
        initialX = currentX;
        initialY = currentY;
        active = false;
      }

      function drag(e) {
        if (active) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          xOffset = currentX;
          yOffset = currentY;
          setTranslate(currentX, currentY, el);
        }
      }

      function setTranslate(xPos, yPos, el) {
        el.style.transform = "translate3d(" + xPos + "px, " + yPos + "px, 0)";
      }
    }

    // Make Dock Draggable (Removed)
    // makeDraggable(document.getElementById('call-dock'));

    // --- VIDEO CALL LOGIC ---
    async function startLocalVideo() {
      if (isCallActive) return;

      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

        // Update Local Bubble
        const bubble = document.getElementById(`bubble-${socket.id}`);
        if (bubble) {
          const vid = bubble.querySelector('video');
          const placeholder = bubble.querySelector('.avatar-placeholder');
          const overlay = bubble.querySelector('.connect-overlay'); // Changed from document.getElementById('connect-overlay')
          const controls = bubble.querySelector('.bubble-controls'); // Changed from document.getElementById('local-controls')

          vid.srcObject = localStream;
          vid.style.display = 'block';
          placeholder.style.display = 'none';
          overlay.style.display = 'none';
          controls.style.display = 'flex';
        }

        isCallActive = true;

        // Signal readiness
        console.log("Emitting join-video for room:", roomCode);
        socket.emit('join-video', roomCode);
        // updatePeerCount(); // No longer needed as bubbles are always there

      } catch (err) {
        console.error("Failed to get local stream", err);
        alert("Could not access camera/microphone.");
      }
    }

    function leaveCall() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      // Close all peer connections
      Object.values(peers).forEach(p => p.close());
      peers = {};

      // Reset Local Bubble
      const bubble = document.getElementById(`bubble-${socket.id}`);
      if (bubble) {
        const vid = bubble.querySelector('video');
        const placeholder = bubble.querySelector('.avatar-placeholder');
        const overlay = bubble.querySelector('.connect-overlay');
        const controls = bubble.querySelector('.bubble-controls');

        vid.srcObject = null;
        vid.style.display = 'none';
        placeholder.style.display = 'flex';
        overlay.style.display = 'flex';
        controls.style.display = 'none';
      }

      // Reset Remote Bubbles
      document.querySelectorAll('.video-bubble').forEach(b => {
        if (b.id !== `bubble-${socket.id}`) { // Exclude local bubble, already handled
          const vid = b.querySelector('video');
          const placeholder = b.querySelector('.avatar-placeholder');
          if (vid) {
            vid.srcObject = null;
            vid.style.display = 'none';
          }
          if (placeholder) {
            placeholder.style.display = 'flex';
          }
        }
      });

      socket.emit('leave-video', roomCode);
      isCallActive = false;
    }

    function toggleMute() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        audioTrack.enabled = !audioTrack.enabled;
        document.getElementById('mute-btn').textContent = audioTrack.enabled ? 'üé§' : '‚ùå';
      }
    }

    function toggleVideo() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        videoTrack.enabled = !videoTrack.enabled;
        document.getElementById('video-btn').textContent = videoTrack.enabled ? 'üì∑' : 'üö´';
      }
    }

    // --- SIGNALING EVENTS ---

    // 1. New User Joined Video -> Create Offer
    socket.on('user-connected-video', async ({ socketId, name }) => {
      if (!isCallActive) return;
      console.log(`New user joined video: ${name} (${socketId})`);
      const peer = createPeer(socketId, socket.id, name);
      peers[socketId] = peer;

      // Add local stream
      localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

      // Create Offer
      const offer = await peer.createOffer();
      await peer.setLocalDescription(offer);
      socket.emit('offer', { target: socketId, caller: socket.id, callerName: userName, sdp: peer.localDescription });
    });

    // 2. Receive Offer -> Create Answer
    socket.on('offer', async (payload) => {
      if (!isCallActive) return;
      console.log(`Received offer from: ${payload.callerName} (${payload.caller})`);
      const peer = createPeer(payload.caller, socket.id, payload.callerName);
      peers[payload.caller] = peer;

      // Add local stream
      localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

      await peer.setRemoteDescription(payload.sdp);
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);

      socket.emit('answer', { target: payload.caller, caller: socket.id, callerName: userName, sdp: peer.localDescription });
    });

    // 3. Receive Answer
    socket.on('answer', async (payload) => {
      console.log(`Received answer from: ${payload.callerName} (${payload.caller})`);
      const peer = peers[payload.caller];
      if (peer) {
        await peer.setRemoteDescription(payload.sdp);
      }
    });

    // 4. Receive ICE Candidate
    socket.on('ice-candidate', async (incoming) => {
      const peer = peers[incoming.caller];
      if (peer) {
        await peer.addIceCandidate(incoming.candidate);
      }
    });

    // 5. User Left Video
    socket.on('user-disconnected-video', (socketId) => {
      if (peers[socketId]) {
        peers[socketId].close();
        delete peers[socketId];
      }
      // Reset bubble to placeholder
      const bubble = document.getElementById(`bubble-${socketId}`);
      if (bubble) {
        bubble.querySelector('video').style.display = 'none';
        bubble.querySelector('.avatar-placeholder').style.display = 'flex';
      }
    });

    // --- REACTION SYSTEM ---
    function sendReaction(emoji) {
      socket.emit('sendReaction', { roomCode, emoji });
      // Optional: Animate locally immediately for better responsiveness
    }

    socket.on('receiveReaction', (emoji) => {
      const el = document.createElement('div');
      el.textContent = emoji;
      el.className = 'floating-emoji';

      // Randomize position slightly
      const randomLeft = Math.random() * 80 + 10; // 10% to 90% width
      el.style.left = randomLeft + '%';

      document.body.appendChild(el);

      // Cleanup
      setTimeout(() => el.remove(), 2000);
    });

    // --- DRAG & DROP LOGIC ---
    const dragItem = document.getElementById('video-chat-container');
    const dragHandle = document.getElementById('drag-handle');
    let active = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    dragHandle.addEventListener("mousedown", dragStart, false);
    document.addEventListener("mouseup", dragEnd, false);
    document.addEventListener("mousemove", drag, false);

    function dragStart(e) {
      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;
      if (e.target === dragHandle || e.target.parentNode === dragHandle) {
        active = true;
      }
    }

    function dragEnd(e) {
      initialX = currentX;
      initialY = currentY;
      active = false;
    }

    function drag(e) {
      if (active) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        xOffset = currentX;
        yOffset = currentY;
        setTranslate(currentX, currentY, dragItem);
      }
    }

    function toggleMinimize() {
      const grid = document.getElementById('video-grid');
      const controls = document.getElementById('call-controls');
      const join = document.getElementById('join-section');

      if (grid.style.display === 'none' && isCallActive) {
        grid.style.display = 'flex';
        controls.style.display = 'flex';
        join.style.display = 'flex';
      } else if (isCallActive) {
        grid.style.display = 'none';
        controls.style.display = 'none';
        join.style.display = 'none';
      } else {
        // If not active, just toggle join button
        join.style.display = join.style.display === 'none' ? 'flex' : 'none';
      }
    }

    function createPeer(targetSocketId, mySocketId, targetName = 'User') {
      const peer = new RTCPeerConnection(rtcConfig);

      peer.oniceconnectionstatechange = () => {
        console.log(`ICE State for ${targetSocketId}:`, peer.iceConnectionState);
        if (peer.iceConnectionState === 'disconnected' || peer.iceConnectionState === 'failed') {
          const bubble = document.getElementById(`bubble-${targetSocketId}`);
          if (bubble) bubble.remove();
          if (peers[targetSocketId]) {
            peers[targetSocketId].close();
            delete peers[targetSocketId];
            updatePeerCount();
          }
        }
      };

      peer.onicecandidate = (e) => {
        if (e.candidate) {
          socket.emit('ice-candidate', { target: targetSocketId, caller: mySocketId, candidate: e.candidate });
        }
      };

      peer.ontrack = (e) => {
        console.log("Received remote stream", e.streams);

        let bubble = document.getElementById(`bubble-${targetSocketId}`);
        if (!bubble) {
          // Fallback creation if updateUsers hasn't run yet
          console.warn("Bubble not found for", targetSocketId, "creating new one.");
          bubble = document.createElement('div');
          bubble.id = `bubble-${targetSocketId}`;
          bubble.className = 'video-bubble';

          const maxX = window.innerWidth - 160;
          const maxY = window.innerHeight - 160;
          bubble.style.top = Math.min(Math.max(100, 100 + Math.random() * 200), maxY) + 'px';
          bubble.style.left = Math.min(Math.max(20, Math.random() * maxX), maxX) + 'px';

          bubble.innerHTML = `
             <div class="avatar-placeholder" style="border: 2px solid rgba(255,255,255,0.3); border-radius: 50%;">${targetName.charAt(0).toUpperCase()}</div>
             <video id="video-${targetSocketId}" autoplay playsinline style="display:none;"></video>
             <div class="name-tag">${targetName}</div> 
           `;
          document.body.appendChild(bubble);
          makeDraggable(bubble);
        }

        const vid = bubble.querySelector('video');
        const placeholder = bubble.querySelector('.avatar-placeholder');

        if (vid) {
          vid.srcObject = e.streams[0];
          vid.style.display = 'block';
          if (placeholder) placeholder.style.display = 'none';

          vid.onloadedmetadata = () => {
            console.log(`Video loaded for ${targetSocketId}: ${vid.videoWidth}x${vid.videoHeight}`);
            vid.play().catch(err => {
              console.error("Video play failed:", err);
              showToast(`Video autoplay failed for ${targetName}`, "error");
            });
          };
        }
      };

      return peer;
    }
  </script>

</body>

</html>