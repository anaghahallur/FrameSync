<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room â€¢ FrameSync</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@500;700;800;900&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
      min-height: 100vh;
      font-family: 'Inter', sans-serif;
      color: white;
      padding: 30px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      gap: 30px;
      height: calc(100vh - 60px);
    }

    .video-section {
      flex: 3;
      background: rgba(15, 22, 40, 0.95);
      border-radius: 36px;
      border: 2.5px solid #00eeff;
      padding: 30px;
      box-shadow: 0 0 80px rgba(0, 238, 255, 0.4);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      /* Allow scrolling if video grid grows */
    }

    .side-section {
      flex: 1;
      background: rgba(15, 22, 40, 0.95);
      border-radius: 36px;
      border: 2.5px solid #00eeff;
      padding: 30px;
      box-shadow: 0 0 80px rgba(0, 238, 255, 0.4);
      display: flex;
      flex-direction: column;
    }

    #video-player {
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 24px;
      margin-bottom: 20px;
    }

    .host-controls {
      display: none;
      gap: 15px;
      margin-bottom: 20px;
    }

    input[type="text"],
    input[type="file"] {
      width: 100%;
      padding: 16px;
      background: rgba(255, 255, 255, 0.06);
      border: 2px solid #00eeff;
      border-radius: 16px;
      color: white;
      font-size: 1rem;
    }

    .btn {
      padding: 16px 32px;
      background: linear-gradient(45deg, #00eeff, #00aaff);
      color: black;
      border: none;
      border-radius: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: 0.3s;
    }

    .btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 15px 40px rgba(0, 238, 255, 0.5);
    }

    .leave-btn {
      margin-top: auto;
      background: linear-gradient(45deg, #ff3366, #ff6b9d);
      color: white;
    }

    .user-list,
    .chat-box {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 16px;
      padding: 15px;
      margin-top: 15px;
      height: 200px;
      overflow-y: auto;
    }

    #chat-input {
      margin-top: 15px;
      background: rgba(255, 255, 255, 0.06);
      border: 2px solid #00eeff;
      color: white;
      padding: 16px;
      border-radius: 16px;
    }

    .chat-send-btn {
      margin-top: 10px;
      width: 100%;
    }
  </style>
</head>

<body>

  <div class="container">
    <!-- VIDEO SECTION -->
    <div class="video-section">
      <div id="player-container"
        style="width:100%; aspect-ratio:16/9; background:#000; border-radius:24px; margin-bottom:20px; overflow:hidden; position:relative;">
        <div id="video-player"></div>
        <!-- Remove 'controls' attribute by default -->
        <video id="html5-player" style="width:100%; height:100%; display:none;"></video>

        <!-- GUEST OVERLAY (Blocks interaction) -->
        <div id="guest-overlay"
          style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; z-index:10; cursor:default;">
        </div>
      </div>

      <!-- HOST CONTROLS (Only visible to host) -->
      <div id="host-controls" class="host-controls" style="display:none; flex-direction:column;">
        <input type="text" id="youtube-link" placeholder="Paste YouTube link here...">
        <button class="btn" onclick="loadYouTube()">Load YouTube Video</button>

        <div style="display:flex; gap:10px; align-items:center; margin-top:10px;">
          <button class="btn" onclick="document.getElementById('file-upload').click()" style="flex:1;">Upload
            Video</button>
          <button class="btn" onclick="document.getElementById('sub-upload').click()"
            style="flex:1; background:linear-gradient(45deg, #ff9966, #ff5e62);">Upload Subtitles</button>
        </div>
        <div style="margin-top:5px; color:#aaa; font-size:0.9rem;">
          <span id="file-name">No video chosen</span> | <span id="sub-name">No subtitles</span>
        </div>

        <input type="file" id="file-upload" accept="video/*" style="display:none"
          onchange="handleFileSelect(this, 'video')">
        <input type="file" id="sub-upload" accept=".vtt,.srt" style="display:none"
          onchange="handleFileSelect(this, 'subtitle')">

        <button class="btn" onclick="uploadFiles()" style="margin-top:10px; width:100%;">Play Uploaded Files</button>
      </div>

      <button class="btn leave-btn" onclick="leaveRoom()">Leave Room</button>

      <!-- VIDEO CHAT BAR (Horizontal Strip) -->
      <div id="video-chat-container"
        style="margin-top:20px; background:rgba(0,0,0,0.3); padding:15px; border-radius:24px; border:1px solid rgba(255,255,255,0.1);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <h3 style="margin:0; color:var(--text-main);">Video Chat <span id="peer-count"
              style="font-size:0.8rem; color:#888; margin-left:10px;">(Peers: 0)</span></h3>
          <div style="display:flex; gap:10px;">
            <div id="call-controls" style="display:none; gap:10px;">
              <button onclick="toggleMute()" id="mute-btn"
                style="background:rgba(255,255,255,0.1); border:none; border-radius:50%; width:36px; height:36px; cursor:pointer; display:flex; align-items:center; justify-content:center;">ðŸŽ¤</button>
              <button onclick="toggleVideo()" id="video-btn"
                style="background:rgba(255,255,255,0.1); border:none; border-radius:50%; width:36px; height:36px; cursor:pointer; display:flex; align-items:center; justify-content:center;">ðŸ“·</button>
            </div>
            <button id="join-call-btn" onclick="toggleCall()"
              style="padding:8px 16px; background:var(--accent, #E50914); color:white; border:none; border-radius:8px; cursor:pointer; font-weight:bold;">Join
              Call</button>
          </div>
        </div>

        <div id="video-grid"
          style="display:flex; flex-wrap:wrap; justify-content:center; gap:15px; padding-bottom:5px; display:none; min-height:120px;">
          <!-- Local Video -->
          <div style="position:relative; width:200px; height:150px;">
            <video id="local-video" autoplay muted playsinline
              style="width:100%; height:100%; object-fit:cover; border-radius:12px; background:#000; transform:scaleX(-1); border:2px solid var(--accent);"></video>
            <span
              style="position:absolute; bottom:5px; left:5px; font-size:0.7rem; background:rgba(0,0,0,0.6); padding:2px 6px; border-radius:4px; font-weight:bold;">You</span>
          </div>
        </div>
      </div>
    </div>

    <!-- SIDE PANEL -->
    <div class="side-section">

      <h2>Users in Room</h2>
      <div id="user-list" class="user-list"></div>

      <h2 style="margin-top:40px">Chat</h2>
      <div id="chat-box" class="chat-box"></div>
      <input type="text" id="chat-input" placeholder="Type a message..."
        onkeypress="if(event.key==='Enter') sendMessage()">
      <button class="btn chat-send-btn" onclick="sendMessage()">Send</button>
    </div>
  </div>

  <!-- SOCKET.IO + YOUTUBE API -->
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>

  <script>
    const socket = io();
    const roomCode = new URLSearchParams(window.location.search).get('code');
    const userName = localStorage.getItem('userName') || 'Guest';

    // Use Session Storage to prevent tab conflicts
    const isHost = sessionStorage.getItem('isHost') === 'true';

    let ytPlayer;
    let currentMode = 'youtube'; // 'youtube' or 'file'
    let isSyncing = false; // Prevent feedback loops

    let selectedVideo = null;
    let selectedSubtitle = null;

    // Debounce function to prevent event spam
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // Auth Check
    if (localStorage.getItem('isLoggedIn') !== 'true') {
      alert("You must be logged in to join a room.");
      location.href = 'index.html';
    }

    // Join Room
    const token = localStorage.getItem('token');
    const email = localStorage.getItem('userEmail');
    // We need to fetch our own userId to know who we are for friend requests
    // For now, we'll rely on the server broadcasting events with IDs.
    // Ideally, we should fetch /api/me to get our ID, but we'll use the token/email in joinRoom.

    socket.emit('joinRoom', { roomCode, userName, isHost, token, email });

    // User List with Friend Options
    let myUserId = null;

    socket.on('updateUsers', (users) => {
      // Try to find myself to get my ID (if server sends it back in list)
      // Note: Server sends { name, isHost, userId }
      const me = users.find(u => u.name === userName);
      if (me) myUserId = me.userId;

      document.getElementById('user-list').innerHTML = users.map(u => {
        const hostBadge = u.isHost ? ' <span style="color:#ffd700; font-size:0.9em;">ðŸ‘‘</span>' : '';
        let friendBtn = '';

        // Show Add Friend button if:
        // 1. It's not me
        // 2. Both have IDs
        // 3. We are in a Public Room (Private auto-adds, but showing button doesn't hurt if check fails)
        if (u.userId && myUserId && u.userId !== myUserId) {
          friendBtn = `<button onclick="addFriend(${u.userId})" style="margin-left:10px; padding:2px 8px; font-size:0.8rem; background:var(--accent, #00eeff); border:none; border-radius:4px; color:black; cursor:pointer; font-weight:bold;">+</button>`;
        }

        return `<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:5px;">
                  <span>â€¢ ${u.name}${hostBadge}</span>
                  ${friendBtn}
                </div>`;
      }).join('');
    });

    window.addFriend = function (targetId) {
      if (!myUserId) return showToast("Error: User ID not found", "error");
      socket.emit('addFriend', { fromUserId: myUserId, toUserId: targetId });
      showToast("Friend request sent!", "success");
    };

    // Friend Events
    socket.on('friendRequestReceived', (data) => {
      // Check if it's for me (client-side filter if broadcasted to room)
      // Ideally server sends to specific socket, but we broadcasted to room in server.js
      // We need to know our own ID.
      if (myUserId && data.toUserId === myUserId) {
        const toast = document.createElement('div');
        toast.innerHTML = `
          <p><strong>${data.fromName}</strong> sent a friend request!</p>
          <button onclick="acceptFriend(${data.fromUserId}, this.parentElement)" style="margin-top:5px; background:white; color:black; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Accept</button>
        `;
        toast.style.cssText = `
          position:fixed; bottom:80px; right:30px; z-index:9999;
          background:#00eeff; color:black; padding:16px; border-radius:16px;
          font-weight:700; box-shadow:0 0 40px rgba(0,0,0,0.5);
          animation:slideIn 0.4s;
        `;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 10000);
      }
    });

    window.acceptFriend = function (fromId, toastElem) {
      socket.emit('acceptFriend', { userId: myUserId, friendId: fromId });
      toastElem.remove();
      showToast("Friend request accepted!", "success");
    };

    socket.on('friendRequestAccepted', (data) => {
      if (data.userId === myUserId || data.friendId === myUserId) {
        showToast("You are now friends!", "success");
      }
    });

    // Show host controls AND enable video controls for host
    if (isHost) {
      document.getElementById('host-controls').style.display = 'flex';
      document.getElementById('html5-player').controls = true;
    } else {
      // Enable Overlay for Guests
      document.getElementById('guest-overlay').style.display = 'block';

      // Allow unmuting on click (browser policy)
      document.getElementById('guest-overlay').addEventListener('click', () => {
        if (ytPlayer && ytPlayer.unMute) ytPlayer.unMute();
        const html5 = document.getElementById('html5-player');
        if (html5) html5.muted = false;
      });
    }

    // YouTube Player Setup
    function onYouTubeIframeAPIReady() {
      ytPlayer = new YT.Player('video-player', {
        height: '100%',
        width: '100%',
        playerVars: {
          autoplay: 1,
          controls: isHost ? 1 : 0, // Hide controls for guest
          disablekb: isHost ? 0 : 1, // Disable keyboard for guest
          rel: 0
        },
        events: {
          'onReady': () => console.log("YouTube Ready"),
          'onStateChange': onPlayerStateChange
        }
      });
    }

    function onPlayerStateChange(event) {
      if (isHost && currentMode === 'youtube' && !isSyncing) {
        emitVideoState({
          roomCode,
          mode: 'youtube',
          state: event.data,
          time: ytPlayer.getCurrentTime()
        });
      }
    }

    // HTML5 Player Setup
    const html5Player = document.getElementById('html5-player');
    html5Player.crossOrigin = "anonymous";

    // Debounced Emit
    const emitVideoState = debounce((data) => {
      socket.emit('videoState', data);
    }, 100);

    html5Player.addEventListener('play', () => {
      if (isHost && currentMode === 'file' && !isSyncing) {
        emitVideoState({ roomCode, mode: 'file', state: 'play', time: html5Player.currentTime });
      }
    });

    html5Player.addEventListener('pause', () => {
      if (isHost && currentMode === 'file' && !isSyncing) {
        emitVideoState({ roomCode, mode: 'file', state: 'pause', time: html5Player.currentTime });
      }
    });

    html5Player.addEventListener('seeked', () => {
      if (isHost && currentMode === 'file' && !isSyncing) {
        emitVideoState({ roomCode, mode: 'file', state: 'seek', time: html5Player.currentTime });
      }
    });

    // Load YouTube (Host Only)
    function loadYouTube() {
      if (!isHost) return showToast("Only host can control video", "error");
      const url = document.getElementById('youtube-link').value.trim();
      const videoId = url.match(/(?:v=|\/)([a-zA-Z0-9_-]{11})/)?.[1];
      if (!videoId) return showToast("Invalid YouTube link", "error");

      // Switch to YouTube mode locally
      switchMode('youtube');
      ytPlayer.loadVideoById(videoId);

      socket.emit('loadVideo', { roomCode, videoId });
    }

    // File Selection
    function handleFileSelect(input, type) {
      const file = input.files[0];
      if (!file) return;

      if (type === 'video') {
        selectedVideo = file;
        document.getElementById('file-name').textContent = file.name;
      } else {
        selectedSubtitle = file;
        document.getElementById('sub-name').textContent = file.name;
      }
    }

    // Upload Files (Host Only)
    async function uploadFiles() {
      if (!isHost) return;
      if (!selectedVideo) return showToast("Please select a video file", "error");

      const formData = new FormData();
      formData.append('video', selectedVideo);
      if (selectedSubtitle) {
        formData.append('subtitle', selectedSubtitle);
      }

      showToast("Uploading...", "info");

      try {
        const res = await fetch('/api/upload', { method: 'POST', body: formData });
        const data = await res.json();

        if (data.url) {
          // Switch to File mode locally
          switchMode('file');
          playFile(data.url, data.subtitleUrl);

          socket.emit('loadFile', {
            roomCode,
            url: data.url,
            subtitleUrl: data.subtitleUrl,
            filename: data.filename
          });
          showToast("Upload complete!", "success");
        }
      } catch (err) {
        console.error(err);
        showToast("Upload failed", "error");
      }
    }

    function playFile(url, subtitleUrl) {
      html5Player.src = url;
      html5Player.innerHTML = ''; // Clear old tracks

      if (subtitleUrl) {
        const track = document.createElement('track');
        track.kind = 'subtitles';
        track.label = 'English';
        track.srclang = 'en';
        track.src = subtitleUrl;
        track.default = true;
        html5Player.appendChild(track);

        // Force display using textTracks API
        html5Player.addEventListener('loadedmetadata', () => {
          if (html5Player.textTracks[0]) {
            html5Player.textTracks[0].mode = 'showing';
          }
        }, { once: true });
      }

      html5Player.play();
    }

    function switchMode(mode) {
      currentMode = mode;
      if (mode === 'youtube') {
        document.getElementById('video-player').style.display = 'block';
        document.getElementById('html5-player').style.display = 'none';
        html5Player.pause();
      } else {
        document.getElementById('video-player').style.display = 'none';
        document.getElementById('html5-player').style.display = 'block';
        if (ytPlayer && ytPlayer.pauseVideo) ytPlayer.pauseVideo();
      }
    }

    // Socket Events
    socket.on('loadVideo', (data) => {
      switchMode('youtube');
      if (ytPlayer && ytPlayer.loadVideoById) {
        ytPlayer.loadVideoById(data.videoId);
      }
    });

    socket.on('loadFile', (data) => {
      switchMode('file');
      playFile(data.url, data.subtitleUrl);
      showToast("Host loaded a file: " + data.filename);
    });

    // Sync video state
    socket.on('videoState', (data) => {
      if (isHost) return; // Host ignores incoming sync signals to avoid loops

      isSyncing = true; // Block outgoing events while syncing

      if (data.mode === 'youtube' && currentMode === 'youtube') {
        if (Math.abs(ytPlayer.getCurrentTime() - data.time) > 2) {
          ytPlayer.seekTo(data.time, true);
        }
        if (data.state === 1) ytPlayer.playVideo();
        if (data.state === 2) ytPlayer.pauseVideo();
      }
      else if (data.mode === 'file' && currentMode === 'file') {
        // Only sync if difference is significant to prevent micro-stutters
        if (Math.abs(html5Player.currentTime - data.time) > 0.5) {
          html5Player.currentTime = data.time;
        }
        if (data.state === 'play') html5Player.play().catch(e => console.log("Autoplay blocked"));
        if (data.state === 'pause') html5Player.pause();
      }

      setTimeout(() => isSyncing = false, 500); // Reset sync flag
    });

    // User List (Handled above with Friend Logic)

    // Chat
    socket.on('chatMessage', (msg) => {
      const chat = document.getElementById('chat-box');
      chat.innerHTML += `<p><strong>${msg.name}:</strong> ${msg.text}</p>`;
      chat.scrollTop = chat.scrollHeight;
    });

    // Room Ended
    socket.on('roomEnded', () => {
      alert("The host has left the room. The session has ended.");
      sessionStorage.removeItem('isHost');
      location.href = 'dashboard.html';
    });

    function sendMessage() {
      const input = document.getElementById('chat-input');
      const text = input.value.trim();
      if (text) {
        socket.emit('chatMessage', { roomCode, text });
        input.value = '';
      }
    }

    function leaveRoom() {
      socket.emit('leaveRoom', roomCode);
      sessionStorage.removeItem('isHost');
      location.href = 'dashboard.html';
    }

    // Toast Function
    function showToast(message, type = "info") {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
      position:fixed; bottom:30px; right:30px; z-index:9999;
      background:${type === 'error' ? '#ff3366' : type === 'success' ? '#00ff88' : '#00eeff'};
      color:black; padding:16px 32px; border-radius:16px;
      font-weight:700; box-shadow:0 0 40px rgba(0,0,0,0.5);
      animation:slideIn 0.4s, slideOut 0.4s 2.6s forwards;
    `;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    // CSS Animations
    const style = document.createElement('style');
    style.textContent = `
    @keyframes slideIn { from { transform:translateX(100%); opacity:0; } to { transform:translateX(0); opacity:1; } }
    @keyframes slideOut { to { transform:translateX(100%); opacity:0; } }
  `;
    document.head.appendChild(style);
    // --- WEBRTC VIDEO CHAT LOGIC ---
    let localStream;
    let peers = {}; // socketId -> RTCPeerConnection
    let isCallActive = false;

    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    function updatePeerCount() {
      const count = Object.keys(peers).length;
      console.log("Updating Peer Count:", count, peers);
      document.getElementById('peer-count').textContent = `(Peers: ${count})`;
    }

    async function toggleCall() {
      const btn = document.getElementById('join-call-btn');
      const grid = document.getElementById('video-grid');
      const controls = document.getElementById('call-controls');

      if (!isCallActive) {
        // JOIN CALL
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          document.getElementById('local-video').srcObject = localStream;

          grid.style.display = 'flex';
          controls.style.display = 'flex';
          btn.textContent = "Leave Call";
          btn.style.background = "#666";
          isCallActive = true;

          // Signal readiness
          console.log("Emitting join-video for room:", roomCode);
          socket.emit('join-video', roomCode);
          updatePeerCount(); // Update count for local user joining

        } catch (err) {
          console.error("Failed to get local stream", err);
          alert("Could not access camera/microphone.");
        }
      } else {
        // LEAVE CALL
        leaveCall();
        btn.textContent = "Join Call";
        btn.style.background = "var(--accent, #E50914)";
        grid.style.display = 'none';
        controls.style.display = 'none';
        isCallActive = false;
        updatePeerCount(); // Update count for local user leaving
      }
    }

    function leaveCall() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      // Close all peer connections
      Object.values(peers).forEach(p => p.close());
      peers = {};

      // Remove remote videos
      const grid = document.getElementById('video-grid');
      while (grid.children.length > 1) { // Keep local video container
        grid.removeChild(grid.lastChild);
      }

      socket.emit('leave-video', roomCode);
    }

    function toggleMute() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        audioTrack.enabled = !audioTrack.enabled;
        document.getElementById('mute-btn').textContent = audioTrack.enabled ? 'ðŸŽ¤' : 'âŒ';
      }
    }

    function toggleVideo() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        videoTrack.enabled = !videoTrack.enabled;
        document.getElementById('video-btn').textContent = videoTrack.enabled ? 'ðŸ“·' : 'ðŸš«';
      }
    }

    // --- SIGNALING EVENTS ---

    // 1. New User Joined Video -> Create Offer
    socket.on('user-connected-video', async (socketId) => {
      if (!isCallActive) return;
      console.log("New user joined video:", socketId);
      const peer = createPeer(socketId, socket.id);
      peers[socketId] = peer;
      updatePeerCount();

      // Add local stream
      localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

      // Create Offer
      const offer = await peer.createOffer();
      await peer.setLocalDescription(offer);
      socket.emit('offer', { target: socketId, caller: socket.id, sdp: peer.localDescription });
    });

    // 2. Receive Offer -> Create Answer
    socket.on('offer', async (payload) => {
      if (!isCallActive) return;
      console.log("Received offer from:", payload.caller);
      const peer = createPeer(payload.caller, socket.id);
      peers[payload.caller] = peer;
      updatePeerCount();

      // Add local stream
      localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

      await peer.setRemoteDescription(payload.sdp);
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);

      socket.emit('answer', { target: payload.caller, caller: socket.id, sdp: peer.localDescription });
    });

    // 3. Receive Answer
    socket.on('answer', async (payload) => {
      console.log("Received answer from:", payload.caller);
      const peer = peers[payload.caller];
      if (peer) {
        await peer.setRemoteDescription(payload.sdp);
      }
    });

    // 4. Receive ICE Candidate
    socket.on('ice-candidate', async (incoming) => {
      const peer = peers[incoming.caller];
      if (peer) {
        await peer.addIceCandidate(incoming.candidate);
      }
    });

    // 5. User Left Video
    socket.on('user-disconnected-video', (socketId) => {
      if (peers[socketId]) {
        peers[socketId].close();
        delete peers[socketId];
        updatePeerCount();
      }
      const videoElem = document.getElementById(`video-${socketId}`);
      if (videoElem) videoElem.parentElement.remove(); // Remove container
    });

    function createPeer(targetSocketId, mySocketId) {
      const peer = new RTCPeerConnection(rtcConfig);

      peer.oniceconnectionstatechange = () => {
        console.log(`ICE State for ${targetSocketId}:`, peer.iceConnectionState);
        if (peer.iceConnectionState === 'disconnected' || peer.iceConnectionState === 'failed') {
          const videoElem = document.getElementById(`video-${targetSocketId}`);
          if (videoElem) videoElem.parentElement.remove();
          if (peers[targetSocketId]) {
            peers[targetSocketId].close();
            delete peers[targetSocketId];
            updatePeerCount();
          }
        }
      };

      peer.onicecandidate = (e) => {
        if (e.candidate) {
          socket.emit('ice-candidate', { target: targetSocketId, caller: mySocketId, candidate: e.candidate });
        }
      };

      peer.ontrack = (e) => {
        console.log("Received remote stream");
        const grid = document.getElementById('video-grid');

        let vidContainer = document.getElementById(`video-${targetSocketId}`);
        if (!vidContainer) {
          vidContainer = document.createElement('div');
          vidContainer.style.cssText = 'position:relative; width:200px; height:150px;';
          vidContainer.innerHTML = `
             <video id="video-${targetSocketId}" autoplay playsinline style="width:100%; height:100%; object-fit:cover; border-radius:12px; background:#222;"></video>
           `;
          grid.appendChild(vidContainer);
        }

        const vid = vidContainer.querySelector('video');
        vid.srcObject = e.streams[0];
      };

      return peer;
    }
  </script>

</body>

</html>